
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>操作系统——第二章 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="追着光 成为光,第二章 进程管理
思维导图

一、前驱图和程序执行
1.前驱图
是一个有向无循环图（DAG），用于描述进程之间执行的前后关系
结点：描述一个程序段或进程，或一条语句
有向边：结点之间的偏序或前序关系,"> 
    <meta name="author" content="jagtasp"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="操作系统——第二章 - Hexo"/>
    <meta name="twitter:description" content="追着光 成为光,第二章 进程管理
思维导图

一、前驱图和程序执行
1.前驱图
是一个有向无循环图（DAG），用于描述进程之间执行的前后关系
结点：描述一个程序段或进程，或一条语句
有向边：结点之间的偏序或前序关系,"/>
    
    
    
    
    <meta property="og:site_name" content="Hexo"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="操作系统——第二章 - Hexo"/>
    <meta property="og:description" content="追着光 成为光,第二章 进程管理
思维导图

一、前驱图和程序执行
1.前驱图
是一个有向无循环图（DAG），用于描述进程之间执行的前后关系
结点：描述一个程序段或进程，或一条语句
有向边：结点之间的偏序或前序关系,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.1.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">操作系统——第二章</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">操作系统——第二章</h1>
        <div class="stuff">
            <span>四月 01, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>


        </div>
        <div class="content markdown">
            <p>第二章 进程管理</p>
<p>思维导图</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.png"></p>
<p>一、前驱图和程序执行</p>
<p>1.前驱图</p>
<p>是一个有向无循环图（DAG），用于描述进程之间执行的前后关系</p>
<p>结点：描述一个程序段或进程，或一条语句</p>
<p>有向边：结点之间的偏序或前序关系”→“</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/2.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/3.png"></p>
<p>注意：前驱图中必须不存在循环</p>
<p>2.程序的顺序执行</p>
<p>（1）程序的顺序执行</p>
<p>一个程序由若干个程序段组成，而这些程序段的执行必须是顺序的，这种程序执行的方式就称为程序的顺序执行。</p>
<p>（2）程序顺序执行时的特征</p>
<p>①顺序性：处理机的操作严格按照程序所规定的顺序执行</p>
<p>②封闭性：程序一旦开始执行，其计算结果不受外界因素的影响</p>
<p>③可再现性：程序执行的结果与它的执行速度无关（即与时间无关），而只与初始条件有关</p>
<p>3.程序的并发执行</p>
<p>（1）程序的并发执行</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/4.png"></p>
<p>（2）程序并发执行时的特征</p>
<p>①间断性</p>
<p>在多道程序设计的环境下，程序的并发执行，以及为完成一项任务而相互合作，这些程序之间要共享系统的资源，形成了相互制约的关系。相互制约导致并发程序具有”执行——暂停——执行“这种间断性的活动规律。</p>
<p>②失去封闭性</p>
<p>程序在并发执行时，系统的资源状态由多道程序来改变，程序运行失去封闭性。一程序的运行受到其他程序的影响。</p>
<p>③不可再现性</p>
<p>程序在并发执行时，多次运行初始条件相同的同一程序会得出不同的运行结果。</p>
<p>二、进程的描述</p>
<p>1.进程的定义和特征</p>
<p>在多道程序设计的环境下，为了描述程序在计算机系统内的执行情况，必须引入新的概念——进程。</p>
<p>进程的定义：程序关于某个数据集合的依次执行过程。</p>
<p>进程的其他定义：</p>
<p>（1）行为的一个规则叫做程序，程序在处理机上执行时所发生的活动称为进程。</p>
<p>（2）进程是这样的计算部分，它是可以和其他计算并行的一个计算。</p>
<p>（3）进程（有时称为任务）是一个程序与其数据一道通过处理机的执行所发生的活动。</p>
<p>（4）进程是执行中的程序。</p>
<p>2.进程的特征（与程序相比）</p>
<p>（1）结构特征</p>
<p>进程控制块（PCB）+ 程序 + 数据 &#x3D; 进程实体</p>
<p>（2）动态性——最基本特征</p>
<p>进程：进程实体的一次执行过程，有生命周期</p>
<p>程序：程序是一组有序指令的集合，是静态的概念</p>
<p>（3）并发性</p>
<p>（4）独立性</p>
<p>（5）异步性</p>
<p>进程按各自独立的、不可预估的速度向前推进</p>
<p>3.进程的三种基本状态</p>
<p>（1）就绪状态（Ready）</p>
<p>进程以获得除CPU之外的所有必须的资源，一旦得到CPU控制权，立即可以运行。</p>
<p>（2）运行状态（Running）</p>
<p>进程已获得运行所必需的资源，它的程序正在处理机上执行</p>
<p>（3）阻塞状态（Blocked）</p>
<p>正在执行的进程由于发生某些事件而暂时无法执行时，便放弃处理机而处于暂停状态，称该进程处于阻塞状态或等待状态。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/5.png"></p>
<p>4.挂起状态</p>
<p>（1）引起挂起的原因</p>
<p>终端用户的请求</p>
<p>父进程请求</p>
<p>负荷调节的需要</p>
<p>操作系统的需要</p>
<p>（2）进程状态的转换</p>
<p>引入挂起状态后，增加了挂起状态（静止状态）到非挂起状态（活动状态）的转换，或者相反。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/6.png"></p>
<p>5.进程控制块</p>
<p>进程管理中的数据结构</p>
<p>1.进程控制块（PCB）的作用</p>
<p>存放进程管理和控制信息的数据结构称为进程控制块（PCB），是进程管理和控制的最重要的数据结构，在创建时，建立PCB，并伴随进程运行的全过程，直到进程撤销而撤销。</p>
<p>PCB是进程存在的唯一标志。</p>
<p>系统的所有PCB组织成链表或队列，常驻内存的PCB区。</p>
<p>2.进程控制块中的信息</p>
<p>（1）进程标示符</p>
<p>每个进程都必须有一个唯一的标识符</p>
<p>內部标识符   外部标识符</p>
<p>（2）处理机状态</p>
<p>处理机状态信息主要由处理机的各种寄存器中的内容组成。处理机运行时的信息存放在寄存器中，当被中断时这些信息要存放在PCB中。</p>
<p>通用寄存器</p>
<p>指令寄存器</p>
<p>程序状态字  PSW</p>
<p>用户栈指针</p>
<p>（3）进程调度信息</p>
<p>进程状态</p>
<p>进程优先级</p>
<p>进程调度所需的其他信息</p>
<p>事件</p>
<p>（4）进程控制信息</p>
<p>程序和数据的地址</p>
<p>进程通信和同步机制</p>
<p>资源清单</p>
<p>链接指针</p>
<p>3.进程控制块的在组织方式</p>
<p>（1）线性方式</p>
<p>（2）链接方式</p>
<p>把具有同一状态的PCB用其中的链接字链接成一个队列、</p>
<p>就绪队列；若干个阻塞队列；</p>
<p>（3）索引方式</p>
<p>系统根据所有进程的状态建立几张索引表，把各表的内容首地址记录在内存的专用单元中。索引表的标目中记录了相应状态的某个PCB在PCB表中的地址。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/7.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/8.png"></p>
<p>三、进程控制</p>
<p>1.进程的创建</p>
<p>（1）进程图</p>
<p>描述进程家族关系的有向树</p>
<p>（2）引起创建进程的事件</p>
<p>多道程序环境中，只有进程才能在系统中运行</p>
<p>①用户登录</p>
<p>②作业调度</p>
<p>③提供服务</p>
<p>④应用请求</p>
<p>（3）进程的创建</p>
<p>操作系统发现要求创建新进程的事件后，调用进程的原语Creat()创建进程。</p>
<p>进程的创建过程：</p>
<p>申请空白PCB→为新进程分配资源→初始化进程控制块→将新进程插入就绪队列</p>
<p>2.进程的终止</p>
<p>（1）引起进程终止的事件</p>
<p>①正常结束</p>
<p>②异常结束</p>
<p>越界错误；非法指令等</p>
<p>③外界干预</p>
<p>操作员或操作系统干预；父进程请求；父进程终止</p>
<p>（2）进程的终止过程</p>
<p>找出被终止进程的PCB→若进程状态为运行状态，置CPU调度标志为真→若其有子孙进程，终止其子孙进程并回收其资源→回收终止进程的资源→回收终止进程的PCB</p>
<p>3.进程的阻塞与唤醒</p>
<p>（1）引起进程阻塞和唤醒的事件</p>
<p>①请求系统服务</p>
<p>②启动某种操作</p>
<p>③新数据尚未到达</p>
<p>④无新工作可做</p>
<p>（2）进程阻塞过程</p>
<p>调用阻塞原语阻塞自己→将PCB中的状态改为阻塞，并加入阻塞队列→转进程调度</p>
<p>（3）进程唤醒过程</p>
<p>阻塞进程等待的事件发生，有关进程调用唤醒原语唤醒等待该事件的进程</p>
<p>把阻塞进程从等待该事件的阻塞队列中移出→置进程状态为就绪状态，将PCB插入到就绪队列中</p>
<p>阻塞原语和唤醒原语作用相反，成对使用</p>
<p>4.进程的挂起与激活</p>
<p>（1）进程挂起的过程</p>
<p>当出现引起进程挂起的事件时，系统利用挂起原语将指定的进程 或处于阻塞的进程挂起</p>
<p>检查被挂起进程的状态：</p>
<p>若处于活动就绪，则改为静止就绪；</p>
<p>若处于活动阻塞，则改为静止阻塞；</p>
<p>若挂起的进程正在执行，则重新进行进程调度</p>
<p>（2）进程的激活过程</p>
<p>当发生激活进程的事件时，系统利用激活原语将指定进程激活</p>
<p>①激活原语将进程从外存调入内存</p>
<p>②检查该进程的状态：</p>
<p>若为静止就绪，则改为活动就绪</p>
<p>若处于静止阻塞，则改为活动阻塞</p>
<p>四、进程同步</p>
<p>进程同步的主要任务：使并发执行的诸进程之间有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
<p>1.进程同步基本概念</p>
<p>（1）进程间两种形式的制约关系</p>
<p>间接制约关系——源于资源共享</p>
<p>直接制约关系——源于进程合作</p>
<p>（2）临界资源——互斥访问</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/9.png"></p>
<p>进程同步：</p>
<p>生产者和消费者进程共享的变量</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/10.png"></p>
<p>用数组表示具有n个缓冲区的缓冲池</p>
<p>注意：缓冲池组织为循环缓冲，输入指针加1表示in &#x3D; （in+1）mod n，输出指针加1表示为out &#x3D; （out + 1）mod n，当（in + 1）mod n &#x3D; out时表示缓冲池满，in &#x3D; out表示缓冲池空。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/11.png"></p>
<p>（3）临界区</p>
<p>每个进程中访问临界资源的那段代码</p>
<p>访问临界区的程序设计为：</p>
<p>对欲访问的临界资源进行检查</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/12.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/13.png"></p>
<p>进程同步：某进程未获得合作进程发来消息之前该进程等待，消息到来之后方可继续执行的合作关系</p>
<p>同步机构（同步机制）：系统用来实现进程间同步与互斥的机构</p>
<p>（4）同步机制应遵循的规则</p>
<p>①空闲让进</p>
<p>②忙则等待</p>
<p>③有限等待</p>
<p>④让权等待</p>
<p>2.信号量机制</p>
<p>（1）整型信号量</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/14.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/15.png"></p>
<p>未遵循”让权等待“原则，导致忙等</p>
<p>（2）记录型信号量</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/16.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/17.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/18.png"></p>
<p>五、经典的进程同步问题</p>
<p>1.生产者——消费者问题</p>
<p>相互合作的进程关系的一种抽象</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/19.png"></p>
<p>生产者进程和消费者进程都以异步方式运行，但它们之间必须保持同步</p>
<p>（1）利用记录型信号量解决生产者——消费者问题</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/20.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/22.png"></p>
<p>（2）利用AND信号量解决生产者——消费者问题</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/21.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/23.png"></p>
<p>2.哲学家进餐问题</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/24.png"></p>
<p>（1）利用记录型信号量解决哲学家进餐问题</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/25.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/26.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/27.png"></p>
<p>（2）利用AND信号量机制解决哲学家进餐问题</p>
<p>在哲学家进餐问题中，要求每个哲学家先获得两个临界资源（筷子）后方能进餐，本质上是：</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/28.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/29.png"></p>
<p>3.读者——写者问题</p>
<p>一个数据文件或记录可被多个进程共享</p>
<p>只要求读文件的进程称为“Reader进程”，其他进程则称为Writer进程</p>
<p>允许多个进程同时读一个共享对象，但不允许一个writer进程和其他Reader进程或Writer进程同时访问共享对象</p>
<p>“读者——写者问题”是保证一个Writer进程必须与其他进程互斥的访问共享对象的同步问题。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/30.png"></p>
<p>增加一个限制：最多只允许RN个读者同时读</p>
<p>引入信号量L，并赋予其初值RN，通过执行Swait（L，1，1）操作，来控制读者数目</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/31.png"></p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/32.png"></p>
<p>Swait(mx, 1, 0)语句起着开关的作用。只要无writer进程进入写，mx&#x3D;1，reader进程就都可以进入读。但只要一旦有writer进程进入写时，mx&#x3D;0，则任何reader进程就都无法进入读。 </p>
<p>Swait(mx, 1, 1; L, RN, 0)语句表示仅当既无writer进程在写(mx&#x3D;1)，又无reader进程在读(L&#x3D;RN)，writer进程才能进入临界区写。 </p>
<p>六、进程通信</p>
<p>指进程之间的信息交换</p>
<p>1.低级通信：进程间仅交换一些状态和少量数据</p>
<p>进程之间的互斥和同步——低级通信</p>
<p>信号量机制作为通信工具的缺点：</p>
<p>（1）效率低       （2）通信对用户不透明</p>
<p>2.高级通信：进程间可交换大量数据。是指用户可直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式</p>
<p>操作系统隐藏了进程通信的细节，对用户透明，减少了通信程序编制上的复杂性。</p>
<p>3.进程通信的类型</p>
<p>（1）共享存储器系统</p>
<p>相互通信的进程间共享某些数据结构或共享存储区，通过这些空间进行通信。</p>
<p>​        基于共享数据结构的通信方式</p>
<p>进程公用某些数据结构，借以实现诸进程间的信息交换。</p>
<p>实现：程序员——公用数据结构的设置；对进程间同步的处理</p>
<p>操作系统——提供共享存储器</p>
<p>特点：低效。只适合传递相对少量的数据</p>
<p>​        基于共享存储区的通信方式</p>
<p>在存储器中国划出一块共享存储区，诸进程间实现通信</p>
<p>实现：进程在通信前，先向系统申请获得共享存储区中的一个分区，并指定该分区的关键字；把获得的共享存储分区连接到需要进行通信的进程上；此后，便可像读、写普通存储器一样地读、写该公用存储分区。</p>
<p>（2）消息传递系统</p>
<p>进程间的数据交换，以格式化的消息为单位。程序员直接利用系统提供地一组通信命令（原语）进行通信。</p>
<p>（3）管道通信</p>
<p>管道：指用于连接一个读进程和一个写进程以实现它们之间通信的一个打开的共享文件，又名pipe文件。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/33.png"></p>
<p>4.消息通信的实现方法</p>
<p>进程间通信时，源进程可以直接或间接地将消息传送给目标进程</p>
<p>（1）直接通信方式</p>
<p>发送进程利用OS提供的发送命令，直接把消息发送给目标进程。发送进程和接收进程都以显式方式提供对方的标识符。 </p>
<p>通信原语：</p>
<p>Send(Receiver, message);         发送一个消息给接收进程</p>
<p>Receive(Sender, message);       接收Sender发来的消息</p>
<p>利用直接通信原语解决生产者——消费者问题</p>
<p>当生产者生产出一个产品(消息)后，便用Send原语将消息发送给消费者进程；而消费者进程则利用Receive原语来得到一个消息。若消息尚未产生出来，消费者必须等待，直至生产者进程将消息发送过来。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/34.png"></p>
<p>（2）间接通信方式——通过邮箱通信</p>
<p>消息在信箱中可安全保存，只允许核准的目标用户随时读取</p>
<p>利用信箱通信方式，既可实时通信，又可非实时通信。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/35.png"></p>
<p>系统为信箱通信提供若干原语： </p>
<p>信箱的创建和撤消</p>
<p>消息的发送和接收</p>
<p>Send(mailbox, message);  将一个消息发送到指定信箱</p>
<p>Receive(mailbox, message);  从指定信箱中接收一个消息</p>
<p>进程通信时,(发送进程，接收进程)间关系:</p>
<p>一对一； 多对一； 一对多； 多对多</p>
<p>七、线程地基本概念</p>
<p>1.线程的引入</p>
<p>引入进程的目的：使多个程序能并发执行，提高资源利用率和系统吞吐量</p>
<p>进程的基本属性：</p>
<p>进程是一个拥有资源的独立单位</p>
<p>进程同时又是一个独立调度和分派的基本单位</p>
<p>系统进行的其他操作：创建进程；撤销进程；进程切换</p>
<p>将进程的两个基本属性分开：作为调度和分派的基本单位，不同时作为拥有资源的单位，以“轻装上阵”；</p>
<p>对于拥有资源的基本单位，又不对之进行频繁切换。</p>
<p>线程是进程的一条执行路径，它包含独立的堆栈和CPU寄存器状态，每个线程共享其所附属的进程的所有的资源，包括打开的文件、页表（因此也就共享整个用户态地址空间）、信号标识及动态分配的内存等等。</p>
<p>线程和进程的关系是：线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一物理内存空间，当进程退出时该进程所产生的线程都会被强制退出并清除。 </p>
<p>2.线程的属性</p>
<p>（1）轻型实体（为进程的一个实体）：只有一点必不可少的、能保证独立运行的资源</p>
<p>（2）独立调度和分派的基本单位</p>
<p>（3）可并发执行</p>
<p>（4）共享进程资源</p>
<p>在多线程OS中，通常一个进程包括多个线程，每个线程是利用CPU的基本单位，是花费最小开销的实体。 </p>
<p>引入线程的目的：</p>
<p>减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p>
<p>3.线程的状态</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/36.png"></p>
<p>4.线程的创建和终止</p>
<p>在多线程OS中，应用程序启动时，通常只有一个线程(初始化线程)在执行，它根据需要可创建若干线程。</p>
<p>创建新线程时，需要利用线程创建函数(或系统调用)，并提供相应参数。线程创建函数执行完后，返回一个线程标识符供以后使用。</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/37.png"></p>
<p>5.多线程OS中的进程</p>
<p>在多线程OS中，进程是作为拥有系统资源的基本单位，通常进程都包含多个线程并为它们提供资源，但进程不再作为一个执行的实体。 </p>
<p>此时进程的属性：</p>
<p>（1）作为系统资源分配的单元</p>
<p>（2）可包括多个线程</p>
<p>（3）进程不是一个执行的实体</p>
<p><img src="/2022/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0/38.png"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="tryes"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
        <div class="side">
				
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
